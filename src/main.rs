mod ast;
mod lexer;
mod parser;
mod interpreter;
mod codegen;  // New module for native code generation

use std::env;
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::Instant;

use parser::Parser;
use interpreter::Interpreter;
use codegen::CodeGenerator;  // New import

const VERSION: &str = "0.2.0";

fn print_help() {
    println!("Kode Programming Language v{}", VERSION);
    println!("Usage: kode [COMMAND] [OPTIONS]");
    println!("\nCommands:");
    println!("  run <file.kode>      Run a Kode program");
    println!("  build <file.kode>    Compile a Kode program to a .kdc file");
    println!("  repl                 Start an interactive REPL session");
    println!("  version              Show compiler version");
    println!("  help                 Show this help message");
    println!("\nOptions:");
    println!("  --verbose            Enable verbose output");
    println!("  --optimize           Enable optimization (build command)");
    println!("  --time               Show execution time");
    println!("  --no-run             Build only, don't run (build command)");
}

fn print_version() {
    println!("Kode Programming Language v{}", VERSION);
    println!("Copyright 2025");
}

fn validate_file_path(file_path: &str) -> Result<PathBuf, String> {
    if !file_path.ends_with(".kode") {
        return Err("Error: File must have a .kode extension".into());
    }

    let path = Path::new(file_path);
    if !path.exists() {
        return Err(format!("Error: File '{}' does not exist", file_path));
    }

    Ok(path.to_path_buf())
}

fn run_file(file_path: &str, verbose: bool, time_execution: bool) -> Result<(), String> {
    let path = validate_file_path(file_path)?;
    
    if verbose {
        println!("Running file: {}", file_path);
    }

    let source_code = fs::read_to_string(&path)
        .map_err(|e| format!("Error reading file {}: {}", file_path, e))?;

    let mut parser = Parser::new(file_path, &source_code)
        .map_err(|e| format!("Parser initialization error: {}", e))?;

    let start_parse = Instant::now();
    let ast = parser.parse()
        .map_err(|e| format!("Parse error: {}", e))?;
    let parse_duration = start_parse.elapsed();

    if verbose {
        println!("Successfully parsed AST (took {:?})", parse_duration);
    }

    let mut interpreter = Interpreter::new();
    let base_dir = path.parent().unwrap_or_else(|| Path::new("."));
    interpreter.set_base_path(base_dir);

    let start_execution = Instant::now();
    interpreter.run(ast)
        .map_err(|e| format!("Runtime error: {}", e))?;
    let execution_duration = start_execution.elapsed();

    if verbose || time_execution {
        println!("Program executed successfully in {:?}", execution_duration);
        if verbose {
            println!("Total time: {:?}", parse_duration + execution_duration);
        }
    } else if verbose {
        println!("Program executed successfully");
    }

    Ok(())
}

fn build_file(file_path: &str, verbose: bool, _optimize: bool, no_run: bool) -> Result<(), String> {
    let path = validate_file_path(file_path)?;
    
    if verbose {
        println!("Building file: {}", file_path);
    }

    // Read and parse source code
    let source_code = fs::read_to_string(&path)
        .map_err(|e| format!("Error reading file {}: {}", file_path, e))?;

    let mut parser = Parser::new(file_path, &source_code)
        .map_err(|e| format!("Parser initialization error: {}", e))?;

    let start_parse = Instant::now();
    let ast = parser.parse()
        .map_err(|e| format!("Parse error: {}", e))?;
    let parse_duration = start_parse.elapsed();

    if verbose {
        println!("Successfully parsed AST (took {:?})", parse_duration);
    }

    // Create .kdc file
    let kdc_path = path.with_extension("kdc");
    
    // Serialize AST to bytecode file
    let bytecode_start = Instant::now();
    let bytecode = bincode::serialize(&ast)
        .map_err(|e| format!("Failed to serialize bytecode: {}", e))?;
    
    fs::write(&kdc_path, bytecode)
        .map_err(|e| format!("Failed to write .kdc file: {}", e))?;
    
    let bytecode_duration = bytecode_start.elapsed();
    
    if verbose {
        println!("Generated bytecode file (took {:?})", bytecode_duration);
    }

    println!("Build successful: Bytecode file generated at {}", kdc_path.display());

    // Run if --no-run is not specified
    if !no_run {
        println!("Running the compiled file...");
        run_file(&kdc_path.to_string_lossy(), verbose, false)?;
    }

    Ok(())
}

// Add this function to run .kdc files
fn run_bytecode_file(file_path: &str, verbose: bool) -> Result<(), String> {
    let bytecode = fs::read(file_path)
        .map_err(|e| format!("Error reading .kdc file: {}", e))?;
    
    let ast: Vec<ast::Statement> = bincode::deserialize(&bytecode)
        .map_err(|e| format!("Error deserializing bytecode: {}", e))?;
    
    let start_execution = Instant::now();
    let mut interpreter = Interpreter::new();
    interpreter.run(ast)?;
    
    if verbose {
        println!("Program executed successfully in {:?}", start_execution.elapsed());
    }
    
    Ok(())
}

fn repl() -> Result<(), String> {
    println!("Kode Programming Language v{} REPL", VERSION);
    println!("Type 'exit' or press Ctrl+C to quit");
    println!("Type 'help' for available commands");

    let mut interpreter = Interpreter::new();
    
    loop {
        print!("> ");
        io::stdout().flush().map_err(|e| e.to_string())?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input).map_err(|e| e.to_string())?;
        
        let input = input.trim();
        if input.is_empty() {
            continue;
        }
        
        match input {
            "exit" => break,
            "help" => {
                println!("Available commands:");
                println!("  help    Show this help message");
                println!("  exit    Exit the REPL");
                println!("  clear   Clear the screen");
                continue;
            }
            "clear" => {
                print!("\x1B[2J\x1B[1;1H");
                continue;
            }
            _ => {
                let mut parser = Parser::new("<repl>", input)
                    .map_err(|e| format!("Parser initialization error: {}", e))?;
                
                match parser.parse() {
                    Ok(ast) => {
                        if let Err(e) = interpreter.run(ast) {
                            println!("Runtime error: {}", e);
                        }
                    }
                    Err(e) => println!("Parse error: {}", e),
                }
            }
        }
    }
    
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();
    
    if args.len() < 2 {
        print_help();
        return Err("Not enough arguments".into());
    }

    let command = &args[1];
    let mut verbose = false;
    let mut optimize = false;
    let mut time_execution = false;
    let mut no_run = false;
    
    // Process options
    for arg in &args[2..] {
        match arg.as_str() {
            "--verbose" => verbose = true,
            "--optimize" => optimize = true,
            "--time" => time_execution = true,
            "--no-run" => no_run = true,
            _ => {}
        }
    }

    match command.as_str() {
        "run" => {
    if args.len() < 3 {
        return Err("Error: No input file specified".into());
    }

    let file_path = &args[2];

    if file_path.ends_with(".kdc") {
        run_bytecode_file(file_path, verbose)
            .map_err(|e| -> Box<dyn std::error::Error> { e.into() })?;
    } else if file_path.ends_with(".kode") {
        run_file(file_path, verbose, time_execution)
            .map_err(|e| -> Box<dyn std::error::Error> { e.into() })?;
    } else {
        return Err("Unsupported file type. Only .kode and .kdc are allowed.".into());
    }
}

        "build" => {
            if args.len() < 3 {
                return Err("Error: No input file specified".into());
            } else {
                build_file(&args[2], verbose, optimize, no_run)
                    .map_err(|e| -> Box<dyn std::error::Error> { e.into() })?;
            }
        }
        "repl" => {
            repl().map_err(|e| -> Box<dyn std::error::Error> { e.into() })?;
        }
        "version" => {
            print_version();
        }
        "help" => {
            print_help();
        }
        _ => {
            print_help();
            return Err(format!("Unknown command: {}", command).into());
        }
    };

    Ok(())
}